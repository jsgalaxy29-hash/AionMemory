@using System.Text.Json
@using Aion.Domain
@using AionMemory.Logic
@using Microsoft.AspNetCore.Components.Forms
@inherits OwningComponentBase
<EditForm Model="FieldValues" OnValidSubmit="HandleValidSubmit">
    <DataAnnotationsValidator />
    <div class="form-row">
        @if (ResolvedTable is not null)
        {
            @foreach (var field in ResolvedTable.Fields)
            {
                <div>
                    <label>@field.Label</label>
                    @switch (field.DataType)
                    {
                        case FieldDataType.Text:
                        case FieldDataType.Lookup:
                        case FieldDataType.Tags:
                        case FieldDataType.File:
                            <InputText class="input" Value="@GetString(field.Name)" ValueChanged="v => SetValue(field.Name, v)" ValueExpression="() => GetString(field.Name)" />
                            break;
                        case FieldDataType.Note:
                            <InputTextArea class="input" Value="@GetString(field.Name)" ValueChanged="v => SetValue(field.Name, v)" ValueExpression="() => GetString(field.Name)" />
                            break;
                        case FieldDataType.Number:
                            <InputNumber TValue="long?" class="input" Value="@GetLong(field.Name)" ValueChanged="v => SetValue(field.Name, v)" ValueExpression="() => GetLong(field.Name)" />
                            break;
                        case FieldDataType.Decimal:
                            <InputNumber TValue="decimal?" class="input" Value="@GetDecimal(field.Name)" ValueChanged="v => SetValue(field.Name, v)" ValueExpression="() => GetDecimal(field.Name)" />
                            break;
                        case FieldDataType.Boolean:
                            <InputCheckbox class="input" Value="@GetBool(field.Name)" ValueChanged="v => SetValue(field.Name, v)" ValueExpression="() => GetBool(field.Name)" />
                            break;
                        case FieldDataType.Date:
                        case FieldDataType.DateTime:
                            <InputDate TValue="DateTime?" class="input" Value="@GetDateTime(field.Name)" ValueChanged="v => SetValue(field.Name, v)" ValueExpression="() => GetDateTime(field.Name)" />
                            break;
                        default:
                            <InputText class="input" Value="@GetString(field.Name)" ValueChanged="v => SetValue(field.Name, v)" ValueExpression="() => GetString(field.Name)" />
                            break;
                    }
                </div>
            }
        }
    </div>
    <div style="margin-top:12px; display:flex; gap:8px;">
        <button type="submit" class="button">Enregistrer</button>
        <button type="button" class="button secondary" @onclick="Reset">Annuler</button>
        @if (ActiveRecordId.HasValue)
        {
            <button type="button" class="button danger" @onclick="Delete">Supprimer</button>
        }
    </div>
</EditForm>

@code {
    [Parameter] public STable? Table { get; set; }
    [Parameter] public Guid? TableId { get; set; }
    [Parameter] public string? TableName { get; set; }
    [Parameter] public IDataEngine? DataEngine { get; set; }
    [Parameter] public Guid? RecordId { get; set; }
    [Parameter] public F_Record? Record { get; set; }
    [Parameter] public EventCallback<F_Record> OnSaved { get; set; }
    [Parameter] public EventCallback<Guid> OnDeleted { get; set; }

    private Dictionary<string, object?> FieldValues { get; set; } = new();
    private STable? LoadedTable { get; set; }
    private Guid? ActiveRecordId => Record?.Id ?? RecordId;
    private STable? ResolvedTable => Table ?? LoadedTable;

    protected override async Task OnParametersSetAsync()
    {
        if (DataEngine is null)
        {
            return;
        }

        if (ResolvedTable is null)
        {
            await LoadTableMetadata();
        }

        await LoadExistingRecord();
        InitializeDefaults();
    }

    private string? GetString(string key) => FieldValues.TryGetValue(key, out var value) ? value?.ToString() : null;

    private DateTime? GetDateTime(string key)
    {
        if (FieldValues.TryGetValue(key, out var value))
        {
            if (value is System.Text.Json.JsonElement element)
            {
                if (element.ValueKind == System.Text.Json.JsonValueKind.String && DateTime.TryParse(element.GetString(), out var parsed))
                {
                    return parsed;
                }

                if (element.ValueKind == System.Text.Json.JsonValueKind.Number && element.TryGetInt64(out var timestamp))
                {
                    return DateTimeOffset.FromUnixTimeSeconds(timestamp).DateTime;
                }
            }

            if (value is DateTime dateTime)
            {
                return dateTime;
            }
        }

        return null;
    }

    private decimal? GetDecimal(string key)
    {
        if (!FieldValues.TryGetValue(key, out var value))
        {
            return null;
        }

        if (value is decimal d)
        {
            return d;
        }

        if (value is JsonElement element && element.ValueKind == JsonValueKind.Number && element.TryGetDecimal(out var parsed))
        {
            return parsed;
        }

        return null;
    }

    private long? GetLong(string key)
    {
        if (!FieldValues.TryGetValue(key, out var value))
        {
            return null;
        }

        switch (value)
        {
            case long l:
                return l;
            case int i:
                return i;
            case decimal d:
                return (long)d;
            case JsonElement element when element.ValueKind == JsonValueKind.Number && element.TryGetInt64(out var parsed):
                return parsed;
        }

        return null;
    }

    private bool GetBool(string key)
    {
        if (!FieldValues.TryGetValue(key, out var value))
        {
            return false;
        }

        if (value is bool b)
        {
            return b;
        }

        if (value is JsonElement element && element.ValueKind is JsonValueKind.True or JsonValueKind.False)
        {
            return element.GetBoolean();
        }

        return false;
    }

    private void SetValue(string key, object? value) => FieldValues[key] = value;

    private async Task HandleValidSubmit()
    {
        if (ResolvedTable is null || DataEngine is null)
        {
            return;
        }

        var payload = System.Text.Json.JsonSerializer.Serialize(FieldValues);
        var record = ActiveRecordId.HasValue
            ? await DataEngine.UpdateAsync(ResolvedTable.Id, ActiveRecordId.Value, payload)
            : await DataEngine.InsertAsync(ResolvedTable.Id, payload);
        await OnSaved.InvokeAsync(record);
        Reset();
    }

    private void Reset()
    {
        FieldValues = new();
    }

    private async Task Delete()
    {
        if (DataEngine is null || ResolvedTable is null || !ActiveRecordId.HasValue)
        {
            return;
        }

        await DataEngine.DeleteAsync(ResolvedTable.Id, ActiveRecordId.Value);
        await OnDeleted.InvokeAsync(ActiveRecordId.Value);
        Reset();
    }

    private async Task LoadExistingRecord()
    {
        if (ActiveRecordId is null || DataEngine is null || ResolvedTable is null)
        {
            return;
        }

        var record = await DataEngine.GetAsync(ResolvedTable.Id, ActiveRecordId.Value);
        if (record is null)
        {
            return;
        }

        FieldValues = DynamicListLogic.DeserializePayload(record.DataJson);
    }

    private async Task LoadTableMetadata()
    {
        if (DataEngine is null)
        {
            return;
        }

        if (TableId.HasValue)
        {
            LoadedTable = await DataEngine.GetTableAsync(TableId.Value);
        }
        else if (!string.IsNullOrWhiteSpace(TableName))
        {
            var allTables = await DataEngine.GetTablesAsync();
            LoadedTable = allTables.FirstOrDefault(t => string.Equals(t.Name, TableName, StringComparison.OrdinalIgnoreCase));
        }
    }

    private void InitializeDefaults()
    {
        if (ResolvedTable is null)
        {
            return;
        }

        foreach (var field in ResolvedTable.Fields)
        {
            if (FieldValues.ContainsKey(field.Name) || string.IsNullOrWhiteSpace(field.DefaultValue))
            {
                continue;
            }

            FieldValues[field.Name] = field.DefaultValue;
        }
    }
}